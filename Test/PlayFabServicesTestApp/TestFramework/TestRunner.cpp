// Copyright (C) Microsoft Corporation. All rights reserved.

#include "TestAppPch.h"
#include <thread>
#include "TestClass.h"
#include "TestContext.h"
#include "TestRunner.h"
#include "EnumTraits.h"
#include "TestTypes.h"
#include "Platform/PlatformUtils.h"
#include "Platform/PlayFabPal.h"
#include "Tests/Core/AuthenticationTests.h"
#include "Tests/Core/EventPipelineTests.h"
#include "Tests/Core/LibHCTests.h"
#include "Generated/GeneratedTestsBootstrapper.h"

#include <httpClient/httpClient.h>
#include <playfab/core/PFTrace.h>
#include <fstream>

namespace PlayFab
{
namespace Test
{

std::atomic<TestRunner*> TestRunner::s_hcTraceCallbackContext = nullptr;

HRESULT TestRunner::Initialize()
{
    // Init tracing
    RETURN_IF_FAILED(HCSettingsSetTraceLevel(HCTraceLevel::Verbose));
    HCTraceSetTraceToDebugger(true);

    // LHC doesn't have a context pointer for the trace callback, so we're using a static member as a callback context
    s_hcTraceCallbackContext = this;
    HCTraceSetClientCallback(PFHCTraceCallback);

    // Init Platform hooks to be used throughout PlayFab tests
    RETURN_IF_FAILED(Platform::SetHooks());

    // Load the TestTitleData
    TestTitleData titleData;
    RETURN_IF_FAILED(Platform::GetTestTitleData(titleData));

    if (titleData.allowRetries && titleData.retryableHRs.size() > 0)
    {
        m_allowRetries = titleData.allowRetries;
        SetretryableHRs(titleData.retryableHRs);
    }

    if (titleData.runTestList && titleData.testList.size() > 0)
    {
        SetTestList(titleData.testList);
    }

    // Initialize the list of TestClasses
    m_testClasses.emplace_back(MakeShared<AuthenticationTests>(titleData));
    m_testClasses.emplace_back(MakeShared<EventPipelineTests>(titleData));
    m_testClasses.emplace_back(MakeShared<LibHCTests>(titleData));

    // Add autogenerated tests
    auto generatedTests = GetGeneratedTestClasses(titleData);
    m_testClasses.insert(m_testClasses.end(), generatedTests.begin(), generatedTests.end());

    m_activeTestClass = m_testClasses.begin();

    return S_OK;
}

void TestRunner::SetTestList(Set<String> testNames)
{
    m_testList = std::move(testNames);
}

void TestRunner::SetretryableHRs(Set<String> retryableHRs)
{
    for (auto& hr : retryableHRs)
    {
        Stringstream ss;
        ss << std::hex << hr;

        unsigned long result;
        ss >> result;

        m_retryableHRs.insert(static_cast<HRESULT>(result));
    }
}

void TestRunner::ProcessRetries()
{
    Set<String> testRetryList = m_testRetryList;
    m_testRetryList.clear();

    for (auto& testClass : m_testClasses)
    {
        auto& testClassTests = testClass->GetTests();
        for (auto& test : testClassTests)
        {
            if (TestFinishState::TIMEDOUT == test->IntermediateState() || TestFinishState::TIMEDOUT == test->FinishState())
            {
                // Retry timeouts if they haven't been previously retried
                bool alreadyRetried = testRetryList.find(test->TestName()) != testRetryList.end();

                if (!alreadyRetried)
                {
                    m_testRetryList.insert(test->TestName());
                }
            }
            else if (TestFinishState::FAILED == test->FinishState())
            {
                bool retryable = false;

                // Check failures and see if they're allowed to be retried.
                Vector<Result<void>> intermediateResults = test->IntermediateResults();
                for (auto& result : intermediateResults)
                {
                    retryable = (m_retryableHRs.find(result.hr) != m_retryableHRs.end() ? true : false);

                    if (!retryable)
                    {
                        break;
                    }
                }

                if (retryable)
                {
                    bool alreadyRetried = testRetryList.find(test->TestName()) != testRetryList.end();

                    if (!alreadyRetried)
                    {
                        m_testRetryList.insert(test->TestName());
                    }
                }
            }
        }
    }
}

bool TestRunner::Update()
{
    if (m_activeTestClass == m_testClasses.end())
    {
        if (m_allowRetries)
        {
            // All Tests done, check for any retries
            ProcessRetries();

            if (m_testRetryList.size() > 0)
            {
                // Retry the failed tests
                m_testList = m_testRetryList;
                m_activeTestClass = m_testClasses.begin();
                return false;
            }
        }

        // All tests done, log test summary. Update() should not be called again after this
        auto testSummary = GenerateTestSummary();
        AddLog(HCTraceLevel::Important, testSummary.c_str());
        return true;
    }

    switch (m_activeTestClassState)
    {
    case TestClassState::Pending:
    {
        // Add the tests from the current TestClass.
        auto& testClassTests = (*m_activeTestClass)->GetTests();

        // If this test class has no tests on m_testList, skip it
        if (!m_testList.empty())
        {
            bool haveTestsToRun = false;
            for (auto& test : testClassTests)
            {
                if (m_testList.find(test->TestName()) != m_testList.end())
                {
                    haveTestsToRun = true;
                    break;
                }
            }
            if (!haveTestsToRun)
            {
                ++m_activeTestClass;
                return false;
            }
        }

        m_activeTestClassTests.insert(m_activeTestClassTests.end(), testClassTests.begin(), testClassTests.end());
        m_activeTest = m_activeTestClassTests.begin();

        // Initialize TestClass
        AddLog(HCTraceLevel::Verbose, "[TestClass] Starting");
        m_activeTestClassState = TestClassState::Initializing;

        (*m_activeTestClass)->Initialize().Finally([this](Result<void> result)
        {
            if (FAILED(result.hr))
            {
                // Fail all tests in the class with the init failure. We'll automatically transition to the next
                // test class on the next call to Update by setting the TestClassState to Active
                for (; m_activeTest != m_activeTestClassTests.end(); ++m_activeTest)
                {
                    (*m_activeTest)->EndTest(result.hr);
                }
            }
            m_activeTestClassState = TestClassState::Active;
        });

        return false;
    }
    case TestClassState::Initializing:
    {
        // Waiting for TestClass:Initialize to finish, nothing to do right now
        return false;
    }
    case TestClassState::Active:
    {
        if (m_activeTest == m_activeTestClassTests.end())
        {
            // If we are at the end of the current TestClass's tests, cleanup
            m_activeTestClassState = TestClassState::Uninitializing;

            (*m_activeTestClass)->Uninitialize().Finally([this](Result<void> result)
            {
                if (FAILED(result.hr))
                {
                    AddLog(HCTraceLevel::Error, "TestClass::Uninitialize failed with hr=0x%08x", result.hr);
                }

                AddLog(HCTraceLevel::Verbose, "[TestClass] Completed");
                m_activeTestClassState = TestClassState::Complete;
            });

            return false;
        }
        else
        {
            // Current test logic below based on its state
            break;
        }
    }
    case TestClassState::Uninitializing:
    {
        // Waiting for TestClass:Uninitialize to finish, nothing to do right now
        return false;
    }
    case TestClassState::Complete:
    {
        // Move to the next test class and return. It will be initialized and run next time Update is called
        m_activeTestClassTests.clear();
        ++m_activeTestClass;
        m_activeTestClassState = TestClassState::Pending;
        return false;
    }
    default:
    {
        assert(false); // Shouldn't get here
        break;
    }
    }

    auto& test{ *m_activeTest };
    if (!m_testList.empty() && (m_testList.find(test->TestName()) == m_testList.end()))
    {
        ++m_activeTest;
        return false;
    }

    switch (test->ActiveState())
    {
    case TestActiveState::PENDING:
    {
        // Begin test
        test->StartTest();
        AddLog(HCTraceLevel::Verbose, "[Test] Starting: %s", test->TestName().c_str());

        // Update TestReport
        m_testReport.TestStarted();

        break;
    }
    case TestActiveState::ACTIVE:
    {
        if (!test->IsExpired())
        {
            (*m_activeTestClass)->Tick(*test);
        }
        else
        {
            test->Timeout();
        }
        break;
    }
    case TestActiveState::COMPLETE:
    {
        String testFinishStateText = EnumName(test->FinishState());
        AddLog(HCTraceLevel::Important, "[Test] Completed: %s %s", test->TestName().c_str(), testFinishStateText.c_str());

        // Update TestReport
        int64_t testDurationMs = test->EndTime() - test->StartTime();
        m_testReport.TestComplete(test->TestName(), test->FinishState(), testDurationMs, test->Summary());

        // Move to next test
        ++m_activeTest;

        break;
    }
    default:
    {
        assert(false); // shouldn't get here
        break;
    }
    }

    return false;
}

// Run the remainder of the currently executing test, cleanup the active TestClass and then return
bool TestRunner::Cleanup()
{
    if (m_activeTestClass != m_testClasses.end())
    {
        if (m_activeTest != m_activeTestClassTests.end())
        {
            auto& test = *m_activeTest;
            while (test->ActiveState() == TestActiveState::ACTIVE)
            {
                Update();
                std::this_thread::yield();
            }
        }

        (*m_activeTestClass)->Uninitialize().Wait();
    }

    s_hcTraceCallbackContext = nullptr;

    return m_testReport.AllTestsPassed();
}

String TestRunner::GenerateTestSummary()
{
    Stringstream summaryStream;

    int64_t timeNow = GetMilliTicks();
    int64_t testStartTime, testEndTime;
    size_t testsCount = 0, testsFinishedCount = 0, testsPassedCount = 0, testsFailedCount = 0, testsSkippedCount = 0;

    for (auto& testClass : m_testClasses)
    {
        auto& testClassTests = testClass->GetTests();
        for (auto& test : testClassTests)
        {
            testsCount += 1;

            // Count tests
            if (TestActiveState::COMPLETE == test->ActiveState())
            {
                testsFinishedCount += 1;

                testStartTime = test->StartTime();
                testEndTime = test->EndTime();

                if (TestFinishState::PASSED == test->FinishState())
                {
                    testsPassedCount += 1;
                }
                else if (TestFinishState::SKIPPED == test->FinishState())
                {
                    testsSkippedCount += 1;
                }
                else
                {
                    testsFailedCount += 1;
                }
            }
            else
            {
                testStartTime = (TestActiveState::PENDING == test->ActiveState()) ? timeNow : test->StartTime();
                testEndTime = timeNow;
            }

            // Line for each test report
            int64_t testDurationMs = testEndTime - testStartTime;
            summaryStream << std::setw(10) << testDurationMs << " ms";
            summaryStream << " - " << EnumName(test->FinishState());
            summaryStream << " - " << test->TestName();
            auto& testSummary = test->Summary();
            if (!testSummary.empty())
            {
                summaryStream << " - " << testSummary;
            }
            summaryStream << "\n";
        }
    }

    summaryStream << " - Testing complete:  ";
    summaryStream << testsFinishedCount << "/" << testsCount << " tests run, ";
    summaryStream << testsPassedCount << " tests passed, ";
    summaryStream << testsFailedCount << " tests failed, ";
    summaryStream << testsSkippedCount << " tests skipped.";

    return summaryStream.str();
}

void TestRunner::AddLog(HCTraceLevel level, _In_z_ _Printf_format_string_ const char* format, ...)
{
    va_list args1;
    va_start(args1, format);

    va_list args2;
    va_copy(args2, args1);

    Vector<char> buf(1 + std::vsnprintf(NULL, 0, format, args1));
    va_end(args1);

    auto ret = std::vsnprintf(buf.data(), buf.size(), format, args2);
    va_end(args2);

    if (ret < 0)
    {
        return;
    }

    Stringstream message;
    message << Platform::GetTimeString() << "\t";
    message << buf.data();
    message << std::endl;

    // Log message inside lock to keep them serialized
    std::lock_guard<std::mutex> lock{ m_mutex };
    Platform::TraceMessage(level, message.str());
}

void TestRunner::PFHCTraceCallback(_In_z_ const char* areaName, _In_ HCTraceLevel level, _In_ uint64_t threadId, _In_ uint64_t timestamp, _In_z_ const char* message)
{
    UNREFERENCED_PARAMETER(areaName);
    UNREFERENCED_PARAMETER(threadId);
    UNREFERENCED_PARAMETER(timestamp);

    TestRunner* runner{ s_hcTraceCallbackContext.load() };
    if (runner)
    {
        runner->AddLog(level, message);
    }
}

} // namespace Test
} // namespace PlayFab
